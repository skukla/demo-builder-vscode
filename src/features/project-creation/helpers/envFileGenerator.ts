/**
 * .env file generation logic for components
 */

import { promises as fsPromises } from 'fs';
import * as path from 'path';
import { formatGroupName } from './formatters';
import { TransformedComponentDefinition, EnvVarDefinition } from '@/types/components';
import type { Logger } from '@/types/logger';

/**
 * ProjectConfig interface for .env generation
 */
interface EnvGenerationConfig {
    componentConfigs?: Record<string, Record<string, string | number | boolean | undefined>>;
    apiMesh?: {
        endpoint?: string;
    };
}

/**
 * Generate component-specific .env file
 * Each component gets its own .env with only the variables it needs
 *
 * @param componentPath - Path to the component directory
 * @param componentId - ID of the component
 * @param componentDef - Component definition from components.json
 * @param sharedEnvVars - Shared environment variable definitions dictionary
 * @param config - Project configuration with user values
 * @param logger - Logger instance for info messages
 */
export async function generateComponentEnvFile(
    componentPath: string,
    componentId: string,
    componentDef: TransformedComponentDefinition,
    sharedEnvVars: Record<string, Omit<EnvVarDefinition, 'key'>>,
    config: EnvGenerationConfig,
    logger: Logger,
): Promise<void> {
    const lines: string[] = [
        `# ${componentDef.name} - Environment Configuration`,
        '# Generated by Demo Builder',
        '# Generated: ' + new Date().toISOString(),
        '',
    ];

    // Get environment variable keys from flat structure (directly in configuration)
    const requiredKeys = componentDef.configuration?.requiredEnvVars || [];
    const optionalKeys = componentDef.configuration?.optionalEnvVars || [];
    const allKeys = [...requiredKeys, ...optionalKeys];

    // Build EnvVarDefinition objects by looking up from shared dictionary
    const relevantVars: EnvVarDefinition[] = [];
    for (const key of allKeys) {
        const envVar = sharedEnvVars[key];
        if (envVar) {
            relevantVars.push({
                key,
                ...envVar,
                usedBy: [componentId],
            });
        }
    }

    if (relevantVars.length > 0) {
        // Group variables by their group
        const groups = new Map<string, EnvVarDefinition[]>();

        for (const envVar of relevantVars) {
            const group = envVar.group || 'general';
            if (!groups.has(group)) {
                groups.set(group, []);
            }
            groups.get(group)!.push(envVar);
        }

        // Write variables grouped by section
        for (const [groupName, vars] of groups.entries()) {
            lines.push(`# ${formatGroupName(groupName)}`);

            for (const envVar of vars) {
                const key = envVar.key;
                let value = '';

                // Priority order for values:
                // 1. Runtime values (e.g., MESH_ENDPOINT from deployment)
                // 2. User-provided values (from wizard - check all components)
                // 3. Default value (from components.json)
                // 4. Empty string

                if (key === 'MESH_ENDPOINT' && config.apiMesh?.endpoint) {
                    value = config.apiMesh.endpoint;
                } else if (config.componentConfigs) {
                    // Check if ANY component has this value (field might be entered under different component)
                    for (const compId in config.componentConfigs) {
                        const configValue = config.componentConfigs[compId]?.[key];
                        if (configValue !== undefined) {
                            value = String(configValue);
                            break;
                        }
                    }
                }

                // Fall back to default value from field definition
                if (!value && envVar.default !== undefined) {
                    value = String(envVar.default);
                }

                // Add description as comment if available
                if (envVar.description) {
                    lines.push(`# ${envVar.description}`);
                }

                lines.push(`${key}=${value || ''}`);
            }

            lines.push('');
        }
    }

    // Determine filename based on component type
    // Next.js uses .env.local, others use .env
    const envFileName = componentDef.id.includes('nextjs') ? '.env.local' : '.env';
    const envFilePath = path.join(componentPath, envFileName);

    // Write the file
    await fsPromises.writeFile(envFilePath, lines.join('\n'));

    logger.info(`[Project Creation] Created ${envFileName} for ${componentDef.name}`);
}
