/**
 * .env file generation logic for components
 */

import { promises as fsPromises } from 'fs';
import * as path from 'path';
import { formatGroupName } from './formatters';
import { normalizeIfUrl } from '@/core/validation/Validator';
import { generateConfigFile } from '@/core/config/configFileGenerator';
import { TransformedComponentDefinition, EnvVarDefinition, ConfigFileDefinition, ComponentRegistry } from '@/types/components';
import { ProjectSetupContext } from '@/features/project-creation/services/ProjectSetupContext';
import { COMPONENT_IDS } from '@/core/constants';
import { generateConfigJson, extractConfigParamsFromConfigs } from '@/features/eds/services/configGenerator';
import type { ConfigGeneratorParams } from '@/features/eds/services/configGenerator';

/**
 * Resolves all environment variable keys for a component, including backend-specific service env vars.
 * Service env vars are only added if NOT already explicitly declared by the component.
 */
function resolveComponentEnvVars(
    componentDef: TransformedComponentDefinition,
    registry: ComponentRegistry,
    backendId?: string,
): string[] {
    const requiredKeys = componentDef.configuration?.requiredEnvVars || [];
    const optionalKeys = componentDef.configuration?.optionalEnvVars || [];
    const explicitKeys = new Set([...requiredKeys, ...optionalKeys]);
    const allEnvVarKeys = [...requiredKeys, ...optionalKeys];

    // Add backend-specific service env vars if component requires services
    if (componentDef.configuration?.requiredServices && backendId) {
        for (const serviceId of componentDef.configuration.requiredServices) {
            const serviceDef = registry.services?.[serviceId];

            if (serviceDef?.backendSpecific && serviceDef.requiredEnvVarsByBackend) {
                const backendSpecificVars = serviceDef.requiredEnvVarsByBackend[backendId];
                if (backendSpecificVars) {
                    const newVars = backendSpecificVars.filter(v => !explicitKeys.has(v));
                    allEnvVarKeys.push(...newVars);
                }
            } else if (serviceDef?.requiredEnvVars) {
                const newVars = serviceDef.requiredEnvVars.filter(v => !explicitKeys.has(v));
                allEnvVarKeys.push(...newVars);
            }
        }
    }

    return allEnvVarKeys;
}

/**
 * @deprecated Use ProjectSetupContext instead
 * Kept for backward compatibility with dashboard configure command
 */
export interface EnvGenerationConfig {
    componentConfigs?: Record<string, Record<string, string | number | boolean | undefined>>;
    apiMesh?: {
        endpoint?: string;
    };
}

/**
 * Minimal context interface for env file generation.
 *
 * Both ProjectSetupContext (for project creation) and ConfigureEnvContext
 * (for dashboard configure) can implement this interface.
 */
export interface EnvGenerationContext {
    /** Component registry with definitions and env vars */
    registry: ComponentRegistry;
    /** Logger for debug output */
    logger: { debug: (message: string, ...args: unknown[]) => void };
    /** Get the selected backend component ID */
    getBackendId(): string | undefined;
    /** Get all component configurations (values from all components) */
    getComponentConfigs(): Record<string, Record<string, string | number | boolean | undefined>> | undefined;
    /** Get shared env var definitions from registry */
    getEnvVarDefinitions(): Record<string, Omit<EnvVarDefinition, 'key'>>;
    /** Get mesh endpoint if available */
    getMeshEndpoint(): string | undefined;
}

/**
 * Generate component-specific .env file using EnvGenerationContext
 *
 * This function pulls values from ALL componentConfigs, not just the component's own config.
 * This enables cross-boundary value sharing (e.g., backend config values in frontend .env).
 *
 * @param componentPath - Path to the component directory
 * @param componentId - ID of the component
 * @param componentDef - Component definition from components.json
 * @param context - Context providing registry, configs, and accessors
 */
export async function generateComponentEnvFile(
    componentPath: string,
    componentId: string,
    componentDef: TransformedComponentDefinition,
    context: EnvGenerationContext,
): Promise<void> {
    const lines: string[] = [
        `# ${componentDef.name} - Environment Configuration`,
        '# Generated by Demo Builder',
        '# Generated: ' + new Date().toISOString(),
        '',
    ];

    // Get all relevant env var keys (component vars + service vars)
    const allKeys = resolveComponentEnvVars(componentDef, context.registry, context.getBackendId());

    // Helper to get value from config
    const getConfigValue = (key: string): string | undefined => {
        const componentConfigs = context.getComponentConfigs();
        if (componentConfigs) {
            for (const compId in componentConfigs) {
                const configValue = componentConfigs[compId]?.[key];
                if (configValue !== undefined) {
                    return String(configValue);
                }
            }
        }
        return undefined;
    };

    // Build EnvVarDefinition objects by looking up from shared dictionary
    const sharedEnvVars = context.getEnvVarDefinitions();
    const varsByKey = new Map<string, EnvVarDefinition>();
    
    // Collect all explicitly required vars, deduplicating by key (first one wins)
    for (const key of allKeys) {
        if (!varsByKey.has(key)) {
            const envVar = sharedEnvVars[key];
            if (envVar) {
                varsByKey.set(key, {
                    key,
                    ...envVar,
                    usedBy: [componentId],
                });
            }
        }
    }

    // Compute derived values using declarative metadata (derivedFrom)
    const derivedValues = new Map<string, string>();
    
    for (const [key, envVar] of varsByKey.entries()) {
        if (envVar.derivedFrom && envVar.derivedFrom.length > 0) {
            // Try each source in order, use first non-empty value
            for (const sourceKey of envVar.derivedFrom) {
                const sourceValue = getConfigValue(sourceKey);
                if (sourceValue) {
                    derivedValues.set(key, sourceValue);
                    context.logger.debug(`[Env Generator] Computed ${key} from ${sourceKey}: ${sourceValue}`);
                    break;
                }
            }
        }
    }

    // Convert deduplicated map to array
    const relevantVars = Array.from(varsByKey.values());

    if (relevantVars.length > 0) {
        // Group variables by their group
        const groups = new Map<string, EnvVarDefinition[]>();

        for (const envVar of relevantVars) {
            const group = envVar.group || 'general';
            if (!groups.has(group)) {
                groups.set(group, []);
            }
            groups.get(group)!.push(envVar);
        }

        // Write variables grouped by section
        for (const [groupName, vars] of groups.entries()) {
            lines.push(`# ${formatGroupName(groupName)}`);

            for (const envVar of vars) {
                const key = envVar.key;
                let value = '';

                // Priority order for values:
                // 1. Derived/computed values (e.g., ADOBE_CATALOG_SERVICE_ENDPOINT)
                // 2. Runtime values (e.g., MESH_ENDPOINT from deployment)
                // 3. User-provided values (from wizard - check all components)
                // 4. Default value (from components.json)
                // 5. Empty string

                if (derivedValues.has(key)) {
                    value = derivedValues.get(key)!;
                } else if (key === 'MESH_ENDPOINT') {
                    const meshEndpoint = context.getMeshEndpoint();
                    if (meshEndpoint) {
                        value = meshEndpoint;
                    }
                } else {
                    const componentConfigs = context.getComponentConfigs();
                    if (componentConfigs) {
                        // Check if ANY component has this value (field might be entered under different component)
                        for (const compId in componentConfigs) {
                            const configValue = componentConfigs[compId]?.[key];
                            if (configValue !== undefined) {
                                value = String(configValue);
                                break;
                            }
                        }
                    }
                }

                // Fall back to default value from field definition
                if (!value && envVar.default !== undefined) {
                    value = String(envVar.default);
                }

                // Add description as comment if available
                if (envVar.description) {
                    lines.push(`# ${envVar.description}`);
                }

                // Normalize URL values (remove trailing slashes)
                const normalizedValue = normalizeIfUrl(value);
                lines.push(`${key}=${normalizedValue || ''}`);
            }

            lines.push('');
        }
    }

    // Determine filename based on component type
    // Next.js uses .env.local, others use .env
    const envFileName = componentDef.id.includes('nextjs') ? '.env.local' : '.env';
    const envFilePath = path.join(componentPath, envFileName);

    // Write the file
    await fsPromises.writeFile(envFilePath, lines.join('\n'));

    context.logger.debug(`[Project Creation] Created ${envFileName} for ${componentDef.name}`);
}

/**
 * Generate all configuration files for a component using ProjectSetupContext
 * 
 * If component has explicit configFiles definition, generates only those files.
 * Otherwise, defaults to generating .env (or .env.local for Next.js).
 * 
 * @param componentPath - Path to the component directory
 * @param componentId - ID of the component
 * @param componentDef - Component definition from components.json
 * @param context - Project setup context with registry, config, logger
 */
export async function generateComponentConfigFiles(
    componentPath: string,
    componentId: string,
    componentDef: TransformedComponentDefinition,
    context: ProjectSetupContext,
): Promise<void> {
    const configFiles = componentDef.configuration?.configFiles;
    
    // If no explicit configFiles, use default .env behavior
    if (!configFiles || Object.keys(configFiles).length === 0) {
        await generateComponentEnvFile(componentPath, componentId, componentDef, context);
        return;
    }
    
    // Generate all explicitly defined config files
    context.logger.debug(`[Project Creation] Generating ${Object.keys(configFiles).length} config file(s) for ${componentDef.name}`);

    for (const [filename, configFileDef] of Object.entries(configFiles)) {
        if (configFileDef.format === 'env') {
            // Generate .env format file
            await generateComponentEnvFile(componentPath, componentId, componentDef, context);
        } else if (configFileDef.generator === 'eds-config') {
            // Use canonical EDS config generator
            await generateEdsConfigJson(componentPath, context);
        } else {
            // Generate other format files (json, yaml, etc.)
            await generateSingleConfigFile(
                componentPath,
                filename,
                configFileDef,
                componentDef,
                context,
            );
        }
    }
}

/**
 * Generate a single non-env configuration file (json, yaml, etc.) using ProjectSetupContext
 * 
 * Takes env vars and optionally renames them for the output format.
 */
async function generateSingleConfigFile(
    componentPath: string,
    filename: string,
    configFileDef: ConfigFileDefinition,
    componentDef: TransformedComponentDefinition,
    context: ProjectSetupContext,
): Promise<void> {
    if (configFileDef.format !== 'json') {
        context.logger.warn(`[Project Creation] Unsupported config file format: ${configFileDef.format} for ${filename}`);
        return;
    }
    
    const filePath = path.join(componentPath, filename);
    const templatePath = configFileDef.template 
        ? path.join(componentPath, configFileDef.template)
        : undefined;
    
    // Get all relevant env var keys (component vars + service vars)
    const allEnvVarKeys = resolveComponentEnvVars(componentDef, context.registry, context.getBackendId());
    
    // Helper to get value from config
    const getConfigValue = (key: string): string | undefined => {
        const componentConfigs = context.getComponentConfigs();
        if (componentConfigs) {
            for (const componentConfig of Object.values(componentConfigs)) {
                if (componentConfig[key] !== undefined) {
                    return String(componentConfig[key]);
                }
            }
        }
        return undefined;
    };
    
    // Compute derived values FIRST (before processing keys)
    const derivedValues = new Map<string, string>();
    
    // Derive ADOBE_CATALOG_SERVICE_ENDPOINT from backend-specific source
    const paasEndpoint = getConfigValue('PAAS_CATALOG_SERVICE_ENDPOINT');
    const accsEndpoint = getConfigValue('ACCS_CATALOG_SERVICE_ENDPOINT');
    if (paasEndpoint || accsEndpoint) {
        const derivedEndpoint = paasEndpoint || accsEndpoint;
        derivedValues.set('ADOBE_CATALOG_SERVICE_ENDPOINT', derivedEndpoint!);
        context.logger.debug(`[Config Generator] Computed ADOBE_CATALOG_SERVICE_ENDPOINT from ${paasEndpoint ? 'PAAS' : 'ACCS'}_CATALOG_SERVICE_ENDPOINT: ${derivedEndpoint}`);
    }
    
    // Add derived keys to the list of keys to process
    const allKeys = [...allEnvVarKeys, ...Array.from(derivedValues.keys())];
    
    // Build the output config
    const outputConfig: Record<string, unknown> = {};
    
    // Process each env var (including derived ones)
    for (const envVarKey of allKeys) {
        let value = '';
        
        // Get value from config
        // Priority: 1. Derived values, 2. Runtime values, 3. User-provided values
        if (derivedValues.has(envVarKey)) {
            value = derivedValues.get(envVarKey)!;
        } else if (envVarKey === 'MESH_ENDPOINT') {
            const meshEndpoint = context.getMeshEndpoint();
            if (meshEndpoint) {
                value = meshEndpoint;
            }
        } else {
            const componentConfigs = context.getComponentConfigs();
            if (componentConfigs) {
                for (const componentConfig of Object.values(componentConfigs)) {
                    if (componentConfig[envVarKey]) {
                        value = String(componentConfig[envVarKey]);
                        break;
                    }
                }
            }
        }
        
        // Determine output field name (rename if mapping exists)
        const outputFieldName = configFileDef.fieldRenames?.[envVarKey] || envVarKey;
        outputConfig[outputFieldName] = value;
    }
    
    // Add additional static fields
    if (configFileDef.additionalFields) {
        Object.assign(outputConfig, configFileDef.additionalFields);
    }
    
    // Generate the file
    if (templatePath) {
        // Build placeholders for template replacement
        const placeholders: Record<string, string> = {};
        for (const [fieldName, value] of Object.entries(outputConfig)) {
            const placeholderKey = `{${fieldName.toUpperCase().replace(/-/g, '_')}}`;
            placeholders[placeholderKey] = String(value || '');
        }
        
        await generateConfigFile({
            filePath,
            templatePath,
            defaultConfig: outputConfig,
            placeholders,
            logger: context.logger,
            description: `${filename} for ${componentDef.name}`,
        });
    } else {
        // No template, write directly
        await fsPromises.writeFile(
            filePath,
            JSON.stringify(outputConfig, null, 2),
            'utf-8'
        );
    }
    
    context.logger.debug(`[Project Creation] Created ${filename} for ${componentDef.name}`);
}

/**
 * Generate config.json for EDS storefront using the canonical config generator
 *
 * This is the single canonical method for generating EDS config.json.
 * It uses the bundled template and replaces placeholders with project-specific values.
 *
 * @param componentPath - Path to the EDS component directory
 * @param context - Project setup context with registry, config, logger
 */
async function generateEdsConfigJson(
    componentPath: string,
    context: ProjectSetupContext,
): Promise<void> {
    const logger = context.logger;

    // Get EDS component instance metadata (populated during EDS setup phases)
    const edsInstance = context.project.componentInstances?.[COMPONENT_IDS.EDS_STOREFRONT];
    const metadata = edsInstance?.metadata || {};

    // Extract GitHub owner and repo from githubRepo (format: "owner/repo")
    const githubRepo = metadata.githubRepo as string | undefined;
    let githubOwner = '';
    let repoName = '';
    if (githubRepo && githubRepo.includes('/')) {
        [githubOwner, repoName] = githubRepo.split('/');
    }

    // Get DA.live org and site
    const daLiveOrg = (metadata.daLiveOrg as string) || '';
    const daLiveSite = (metadata.daLiveSite as string) || '';

    // Extract Commerce config params from componentConfigs
    const componentConfigs = context.getComponentConfigs();
    const meshEndpoint = context.getMeshEndpoint();
    const backendId = context.getBackendId();

    const configParams = extractConfigParamsFromConfigs(componentConfigs, meshEndpoint, backendId);

    // Build full ConfigGeneratorParams
    const params: ConfigGeneratorParams = {
        githubOwner,
        repoName,
        daLiveOrg,
        daLiveSite,
        ...configParams,
    };

    // Validate required params
    if (!githubOwner || !repoName) {
        logger.warn('[Config Generator] Missing GitHub repo info, config.json may have incomplete values');
    }
    if (!daLiveOrg || !daLiveSite) {
        logger.warn('[Config Generator] Missing DA.live info, config.json may have incomplete values');
    }

    // Generate config.json using canonical generator
    const result = generateConfigJson(params, logger);

    if (!result.success || !result.content) {
        // Throw error instead of silent return - caller must know config generation failed
        // This ensures Phase 5 sync doesn't try to push stale/missing config
        throw new Error(`Config.json generation failed: ${result.error || 'Unknown error'}`);
    }

    // Write config.json locally
    const configFilePath = path.join(componentPath, 'config.json');
    await fsPromises.writeFile(configFilePath, result.content, 'utf-8');

    logger.info(`[Config Generator] Created config.json for EDS storefront (env: ${configParams.environmentType || 'paas'})`);
}
